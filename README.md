# Typesafe APIs with Swagger and OpenAPI

Let's say we have basically a monolithic application, but the server and the frontend are separate applications.
There is no motivation to provide the server API to other applications,
so the frontend can be tightly coupled with the API, but we can still benefit from separating both applications.

The usual approach is to manually write the frontend models and clients to communicate with the server API.
That leads to a duplication of the same models which have to be defined on the server application as well.

We can document our server API with OAS, so we can consume it and generate the frontend sources automatically.
To achieve that we will be using several tools and technologies.

The OpenAPI Initiative is a community project that provides open-source specification for describing RESTful APIs.
The OpenAPI Specification (OAS) is a format for describing APIs in a way that is both machine- and human-readable.

Swagger is a set of open-source tools built around the OAS.
Swagger tools can be used to generate documentation, client libraries, server stubs and more.
In this case Swagger is used to automatically generate OAS based on server endpoints and models.

OpenAPI Generator is a tool that generates mainly API client libraries and server stubs.
We will use it to consume the OAS generated by the server application and to automatically generate the frontend sources.
The OpenAPI generator creates libraries by default, so they can be released to private or public repositories.
This project uses very simple setup, therefore the generated sources will be created within the frontend sources.

The picture is worth a thousand words, so it might be easier to understand how it works by looking at the picture.
It was created in draw.io; more information can be found on their sites: <https://www.drawio.com/>.

![openapi.svg](openapi.svg)

By using this setup and all these tools, we ensure that there is no duplication of models,
but furthermore the frontend sources are generated automatically,
so we are minimizing the risk of introducing bugs related to the communication layer between the frontend and the server.

You can find the example project description below, so if you would like to try it yourself, continue reading.

## Further Resources

* OpenAPI initiative landing page: <https://www.openapis.org/>
* Swagger landing page: <https://swagger.io/>
* OpenAPI generator documentation: <https://openapi-generator.tech/>

## Example Project

Follows a description of an example project of frontend and server API communication using Swagger and OpenAPI.

The server is written in Kotlin, and it is using Springdoc <https://springdoc.org/>.
Springdoc is a Spring Boot extension that provides a set of tools for working with the OAS.
It includes a Swagger UI implementation, a code generator, and a documentation generator.

The frontend is an Angular application, and the sources are tightly coupled with the server API.
The OpenAPI generator therefore produces its output inside the Angular source files since it is easier to configure.
and there is no motivation to complicate this example by introducing frontend libraries.

Docker is then used to bring everything together, so it is easier to set up a CI/CD pipeline and to deploy the applications.

### Client-server communication examples

There are several branches with examples of client-server communication.
You can also check individual commits to see the project setup creation step by step.

The following list contains the branch name and a description of an example:

* feature/example-01-http-client - Communication created manually using Angular HttpClient
* feature/example-02-openapi-generator - Communication created by OpenAPI generator
* feature/example-03-enums - Enums handled as references
* feature/example-04-docker - OpenAPI generator in Docker

### Prerequisites

The following applications are installed:

Optional if only Docker is used:
* NodeJS (version min 18.18.0): You can download it from <https://nodejs.org/>
* NPM (version min 10.2.0) - packed with NodeJS, update with `npm install --global npm`
* Angular CLI - execute `npm install --global @angular/cli`
* Execute `npm ci` in the `frontend` directory to install all dependencies
* Java (version min 17), you can download it from:
  * Oracle: <https://www.oracle.com/java/technologies/downloads/>
  * Adoptium: <https://adoptium.net/>
* Gradle (min version 8.4), you can download if from: <https://gradle.org/releases/>

Required:
* Docker Engine: <https://docs.docker.com/engine/install/>
* Docker Compose: <https://docs.docker.com/compose/install/>

### Building the apps locally

Go to the `server` directory and execute `gradle build`.

With the server app running (see instructions below), go to the `frontend` directory and execute `npm run openapi:generate`.
If you are following examples from the start, you may need to execute `npm ci` again to install new dependencies.

### Running the apps locally

First go to the `server` directory, execute `java -jar .\build\libs\server.jar` and leave it running.

Then go to the `frontend` directory, execute `ng serve` and open <http://localhost:4200/> in your browser.

### Building the apps with Docker

To build Docker images execute `docker compose build`.

### Running the apps with Docker

To start Docker containers execute `docker compose up`.
Alternatively execute `docker compose up --build` to build and start all containers without previous build.
